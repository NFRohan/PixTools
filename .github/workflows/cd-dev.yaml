name: CD-Dev

on:
  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    environment: dev
    timeout-minutes: 60

    env:
      AWS_REGION: us-east-1
      ENVIRONMENT: dev
      ECR_API_REPO: pixtools-api
      ECR_WORKER_REPO: pixtools-worker
      MANIFEST_PREFIX: manifests/dev

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          role-session-name: pixtools-dev-cd
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover AWS account ID
        id: aws
        run: echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push API/worker images
        id: image
        env:
          ACCOUNT_ID: ${{ steps.aws.outputs.account_id }}
          SHA_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          API_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_API_REPO}"
          WORKER_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_WORKER_REPO}"

          docker build -t "${API_URI}:${SHA_TAG}" .
          docker tag "${API_URI}:${SHA_TAG}" "${WORKER_URI}:${SHA_TAG}"

          docker push "${API_URI}:${SHA_TAG}"
          docker push "${WORKER_URI}:${SHA_TAG}"

          API_DIGEST="$(aws ecr describe-images --repository-name "${ECR_API_REPO}" --image-ids imageTag="${SHA_TAG}" --query 'imageDetails[0].imageDigest' --output text)"
          WORKER_DIGEST="$(aws ecr describe-images --repository-name "${ECR_WORKER_REPO}" --image-ids imageTag="${SHA_TAG}" --query 'imageDetails[0].imageDigest' --output text)"

          echo "api_image=${API_URI}@${API_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "worker_image=${WORKER_URI}@${WORKER_DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Render Kubernetes manifests
        env:
          API_IMAGE: ${{ steps.image.outputs.api_image }}
          WORKER_IMAGE: ${{ steps.image.outputs.worker_image }}
          ALLOWED_INGRESS_CIDRS: ${{ secrets.ALLOWED_INGRESS_CIDRS }}
          ALB_SECURITY_GROUP_ID: ${{ secrets.ALB_SECURITY_GROUP_ID }}
        run: |
          chmod +x scripts/deploy/render-manifests.sh
          scripts/deploy/render-manifests.sh build/manifests

      - name: Upload rendered manifests to S3
        env:
          MANIFEST_BUCKET: ${{ secrets.MANIFEST_BUCKET }}
        run: |
          aws s3 sync build/manifests "s3://${MANIFEST_BUCKET}/${MANIFEST_PREFIX}" --delete

      - name: Resolve K3s instance
        run: |
          chmod +x scripts/deploy/resolve-k3s-instance.sh
          INSTANCE_ID="$(scripts/deploy/resolve-k3s-instance.sh)"
          echo "Using K3s instance ${INSTANCE_ID}"

      - name: Deploy manifests via SSM command
        env:
          MANIFEST_BUCKET: ${{ secrets.MANIFEST_BUCKET }}
          SSM_WAIT_TIMEOUT_SECONDS: "3300"
        run: |
          INSTANCE_ID="$(scripts/deploy/resolve-k3s-instance.sh)"
          chmod +x scripts/deploy/run-on-ssm.sh
          REMOTE_CMD="$(cat <<EOF
          set -euo pipefail
          dump_debug() {
            kubectl -n pixtools get pods -o wide || true
            kubectl -n pixtools get events --sort-by=.metadata.creationTimestamp | tail -n 120 || true
          }

          mkdir -p /opt/pixtools/manifests
          aws s3 sync s3://${MANIFEST_BUCKET}/${MANIFEST_PREFIX} /opt/pixtools/manifests --delete

          if [ -f /opt/pixtools/manifests/scripts/deploy/reconcile-cluster.sh ]; then
            chmod +x /opt/pixtools/manifests/scripts/deploy/reconcile-cluster.sh
            if ! AWS_REGION=${AWS_REGION} \
              PROJECT=pixtools \
              ENVIRONMENT=${ENVIRONMENT} \
              MANIFEST_BUCKET=${MANIFEST_BUCKET} \
              MANIFEST_PREFIX=${MANIFEST_PREFIX} \
              NAMESPACE=pixtools \
              /opt/pixtools/manifests/scripts/deploy/reconcile-cluster.sh; then
              dump_debug
              exit 1
            fi
          else
            if find /opt/pixtools/manifests -type f -name '*.yaml' -print -quit | grep -q .; then
              if ! find /opt/pixtools/manifests -type f -name '*.yaml' -print0 | xargs -0 -r -n 1 kubectl apply -f; then
                dump_debug
                exit 1
              fi
            else
              echo "No manifest YAML files found at /opt/pixtools/manifests" >&2
              dump_debug
              exit 1
            fi
          fi
          EOF
          )"
          scripts/deploy/run-on-ssm.sh "${INSTANCE_ID}" "${REMOTE_CMD}"

      - name: Post-deploy pod status
        run: |
          INSTANCE_ID="$(scripts/deploy/resolve-k3s-instance.sh)"
          scripts/deploy/run-on-ssm.sh "${INSTANCE_ID}" "kubectl -n pixtools get pods -o wide"

      - name: Resolve ALB hostname from ingress
        id: ingress
        run: |
          INSTANCE_ID="$(scripts/deploy/resolve-k3s-instance.sh)"
          ALB_HOST="$(scripts/deploy/run-on-ssm.sh "${INSTANCE_ID}" "kubectl -n pixtools get ingress pixtools -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'" | tr -d '\r\n' | xargs)"
          if [ -z "${ALB_HOST}" ] || [[ "${ALB_HOST}" != *.elb.amazonaws.com ]]; then
            echo "Failed to resolve ALB hostname from ingress." >&2
            exit 1
          fi
          echo "alb_host=${ALB_HOST}" >> "$GITHUB_OUTPUT"

      - name: Post-deploy smoke test
        env:
          BASE_URL: http://${{ steps.ingress.outputs.alb_host }}
        run: |
          set -euo pipefail
          echo "Smoke testing ${BASE_URL}"

          for i in {1..30}; do
            if curl -fsS "${BASE_URL}/api/health" >/dev/null; then
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "Health check did not become ready in time." >&2
              exit 1
            fi
            sleep 5
          done

          PROCESS_RESPONSE="$(curl -fsS -X POST "${BASE_URL}/api/process" \
            -H "Idempotency-Key: smoke-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}" \
            -F "file=@test_image.png;type=image/png" \
            -F "operations=[\"webp\"]")"

          JOB_ID="$(python -c "import json,sys; print(json.loads(sys.stdin.read())['job_id'])" <<<"${PROCESS_RESPONSE}")"
          if [ -z "${JOB_ID}" ]; then
            echo "Failed to parse job_id from response: ${PROCESS_RESPONSE}" >&2
            exit 1
          fi

          for i in {1..60}; do
            JOB_RESPONSE="$(curl -fsS "${BASE_URL}/api/jobs/${JOB_ID}")"
            STATUS="$(python -c "import json,sys; print(json.loads(sys.stdin.read())['status'])" <<<"${JOB_RESPONSE}")"
            if [ "${STATUS}" = "COMPLETED" ] || [ "${STATUS}" = "COMPLETED_WEBHOOK_FAILED" ]; then
              echo "Smoke job ${JOB_ID} completed with status ${STATUS}"
              exit 0
            fi
            if [ "${STATUS}" = "FAILED" ]; then
              echo "Smoke job ${JOB_ID} failed: ${JOB_RESPONSE}" >&2
              exit 1
            fi
            sleep 2
          done

          echo "Smoke job ${JOB_ID} timed out." >&2
          exit 1
