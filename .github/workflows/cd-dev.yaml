name: CD-Dev

on:
  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    environment: dev
    timeout-minutes: 60

    env:
      AWS_REGION: us-east-1
      ENVIRONMENT: dev
      ECR_API_REPO: pixtools-api
      ECR_WORKER_REPO: pixtools-worker
      MANIFEST_PREFIX: manifests/dev

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          role-session-name: pixtools-dev-cd
          aws-region: ${{ env.AWS_REGION }}

      - name: Discover AWS account ID
        id: aws
        run: echo "account_id=$(aws sts get-caller-identity --query Account --output text)" >> "$GITHUB_OUTPUT"

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push API/worker images
        id: image
        env:
          ACCOUNT_ID: ${{ steps.aws.outputs.account_id }}
          SHA_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail
          API_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_API_REPO}"
          WORKER_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_WORKER_REPO}"

          docker build -t "${API_URI}:${SHA_TAG}" .
          docker tag "${API_URI}:${SHA_TAG}" "${WORKER_URI}:${SHA_TAG}"

          docker push "${API_URI}:${SHA_TAG}"
          docker push "${WORKER_URI}:${SHA_TAG}"

          API_DIGEST="$(aws ecr describe-images --repository-name "${ECR_API_REPO}" --image-ids imageTag="${SHA_TAG}" --query 'imageDetails[0].imageDigest' --output text)"
          WORKER_DIGEST="$(aws ecr describe-images --repository-name "${ECR_WORKER_REPO}" --image-ids imageTag="${SHA_TAG}" --query 'imageDetails[0].imageDigest' --output text)"

          echo "api_image=${API_URI}@${API_DIGEST}" >> "$GITHUB_OUTPUT"
          echo "worker_image=${WORKER_URI}@${WORKER_DIGEST}" >> "$GITHUB_OUTPUT"

      - name: Render Kubernetes manifests
        env:
          API_IMAGE: ${{ steps.image.outputs.api_image }}
          WORKER_IMAGE: ${{ steps.image.outputs.worker_image }}
          ALLOWED_INGRESS_CIDRS: ${{ secrets.ALLOWED_INGRESS_CIDRS }}
          ALB_SECURITY_GROUP_ID: ${{ secrets.ALB_SECURITY_GROUP_ID }}
        run: |
          chmod +x scripts/deploy/render-manifests.sh
          scripts/deploy/render-manifests.sh build/manifests

      - name: Upload rendered manifests to S3
        env:
          MANIFEST_BUCKET: ${{ secrets.MANIFEST_BUCKET }}
        run: |
          aws s3 sync build/manifests "s3://${MANIFEST_BUCKET}/${MANIFEST_PREFIX}" --delete

      - name: Resolve K3s instance ID
        id: ec2
        run: |
          INSTANCE_ID="$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=pixtools-dev-k3s*" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].InstanceId" \
            --output text)"
          if [ -z "${INSTANCE_ID}" ] || [ "${INSTANCE_ID}" = "None" ]; then
            echo "No running K3s instance found." >&2
            exit 1
          fi
          echo "instance_id=${INSTANCE_ID}" >> "$GITHUB_OUTPUT"

      - name: Deploy manifests via SSM command
        env:
          MANIFEST_BUCKET: ${{ secrets.MANIFEST_BUCKET }}
        run: |
          chmod +x scripts/deploy/run-on-ssm.sh
          REMOTE_CMD="$(cat <<EOF
          set -euo pipefail
          mkdir -p /opt/pixtools/manifests/scripts/deploy
          aws s3 cp \
            s3://${MANIFEST_BUCKET}/${MANIFEST_PREFIX}/scripts/deploy/reconcile-cluster.sh \
            /opt/pixtools/manifests/scripts/deploy/reconcile-cluster.sh
          chmod +x /opt/pixtools/manifests/scripts/deploy/reconcile-cluster.sh
          AWS_REGION=${AWS_REGION} \
            PROJECT=pixtools \
            ENVIRONMENT=${ENVIRONMENT} \
            MANIFEST_BUCKET=${MANIFEST_BUCKET} \
            MANIFEST_PREFIX=${MANIFEST_PREFIX} \
            NAMESPACE=pixtools \
            /opt/pixtools/manifests/scripts/deploy/reconcile-cluster.sh
          EOF
          )"
          scripts/deploy/run-on-ssm.sh "${{ steps.ec2.outputs.instance_id }}" "${REMOTE_CMD}"

      - name: Post-deploy pod status
        run: |
          scripts/deploy/run-on-ssm.sh "${{ steps.ec2.outputs.instance_id }}" "kubectl -n pixtools get pods -o wide"

      - name: Resolve ALB hostname from ingress
        id: ingress
        run: |
          ALB_HOST="$(scripts/deploy/run-on-ssm.sh "${{ steps.ec2.outputs.instance_id }}" "kubectl -n pixtools get ingress pixtools -o jsonpath='{.status.loadBalancer.ingress[0].hostname}'" | tr -d '\r\n' | xargs)"
          if [ -z "${ALB_HOST}" ] || [[ "${ALB_HOST}" != *.elb.amazonaws.com ]]; then
            echo "Failed to resolve ALB hostname from ingress." >&2
            exit 1
          fi
          echo "alb_host=${ALB_HOST}" >> "$GITHUB_OUTPUT"

      - name: Post-deploy smoke test
        env:
          BASE_URL: http://${{ steps.ingress.outputs.alb_host }}
        run: |
          set -euo pipefail
          echo "Smoke testing ${BASE_URL}"

          for i in {1..30}; do
            if curl -fsS "${BASE_URL}/api/health" >/dev/null; then
              break
            fi
            if [ "$i" -eq 30 ]; then
              echo "Health check did not become ready in time." >&2
              exit 1
            fi
            sleep 5
          done

          PROCESS_RESPONSE="$(curl -fsS -X POST "${BASE_URL}/api/process" \
            -H "Idempotency-Key: smoke-${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}" \
            -F "file=@test_image.png;type=image/png" \
            -F "operations=[\"webp\"]")"

          JOB_ID="$(python -c "import json,sys; print(json.loads(sys.stdin.read())['job_id'])" <<<"${PROCESS_RESPONSE}")"
          if [ -z "${JOB_ID}" ]; then
            echo "Failed to parse job_id from response: ${PROCESS_RESPONSE}" >&2
            exit 1
          fi

          for i in {1..60}; do
            JOB_RESPONSE="$(curl -fsS "${BASE_URL}/api/jobs/${JOB_ID}")"
            STATUS="$(python -c "import json,sys; print(json.loads(sys.stdin.read())['status'])" <<<"${JOB_RESPONSE}")"
            if [ "${STATUS}" = "COMPLETED" ] || [ "${STATUS}" = "COMPLETED_WEBHOOK_FAILED" ]; then
              echo "Smoke job ${JOB_ID} completed with status ${STATUS}"
              exit 0
            fi
            if [ "${STATUS}" = "FAILED" ]; then
              echo "Smoke job ${JOB_ID} failed: ${JOB_RESPONSE}" >&2
              exit 1
            fi
            sleep 2
          done

          echo "Smoke job ${JOB_ID} timed out." >&2
          exit 1
